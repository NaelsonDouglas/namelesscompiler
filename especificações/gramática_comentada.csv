S = IDT_TYPE_OR_VOID id PARAM o_c_brckt ALL_ITER c_c_brckt S | eof | epsilon, Initial production
TYPE = CONST_R IDT_TYPE, Defines a if the next declaration is a constant or a variable
CONST_R = const | epsilon,Recursive fix for TYPE
IDT_TYPE = idt_int | idt_char | idt_float | idt_string | idt_bool, Type identifiers
IDT_TYPE_OR_VOID = TYPE | idt_void, Type identifiers and void identifier
PARAM = o_brckt PRH, Set of function parameters
PRH = c_brckt | PR c_brckt, Recursive fix for PARAM
PR = TYPE ID_OR_VEC PRL, Recursive fix for PRH
PRL = comma PR | epsilon,Recursive fix for PR
CT_BOOL = ct_true | ct_false, Boolean constants
CT = ct_string | ct_float | ct_int | CT_BOOL, All Constants
FCALL_OR_ATRIB = ID_OR_VEC FCALL_OR_ATRIB_F, Function call of variable attribution
ATRIB = opr_atr EXPR_NUM, Variable attribution handler
FCALL_OR_ATRIB_F = ATRIB | FN_CH, FCALL_OR_ATRIB factoration
VAR_DCLR = IDT_T ID_OR_VEC opr_atr DATA, Variable declaration
DATA = CT | ID_OR_VEC, Constants or IDs
ID_OR_VEC = id VEC_INDX, Simple ID or vector ID
INT_OR_ID = id | ct_int,Integer or ID
VEC_INDX = vec_in VEC_INDX_F | epsilon,The indexer of a vector
VEC_INDX_F = o_brckt EXPR_NUM c_brckt | INT_OR_ID, Factoration of VEC_INDX
EXPR_NUM = EXPR_NUM_K EXPR_NUM_KR, Numeric expression
EXPR_NUM_KR = opr_pm EXPR_NUM | epsilon,#TODO LUCAS
EXPR_NUM_K = EXPR_NUM_G EXPR_NUM_KH,#TODO LUCAS
EXPR_NUM_KH = opr_dm EXPR_NUM_G EXPR_NUM_KH | epsilon,#TODO LUCAS
EXPR_NUM_G = ct_float | ct_int | ID_OR_VEC | o_brckt EXPR_NUM c_brckt,#TODO LUCAS
EXPR_BOOL = EXPR_BOOL_T EXPR_BOOL_H | oprl_not EXPR_BOOL_T EXPR_BOOL_H, Boolean expression
EXPR_BOOL_H = oprlr_or EXPR_BOOL_T EXPR_BOOL_H | epsilon,#TODO LUCAS
EXPR_BOOL_T = EXPR_BOOL_F EXPR_BOOL_TH,#TODO LUCAS
EXPR_BOOL_TH = oprlr_and EXPR_BOOL_F EXPR_BOOL_TH | epsilon,#TODO LUCAS
EXPR_BOOL_F = o_brckt EXPR_BOOL c_brckt | ct_int OPRLR_EQQ_REL EXPR_NUM | ct_float OPRLR_EQQ_REL EXPR_NUM | FN_H_BOOL OPRLR_EQQ_REL EXPR_NUM | ct_false | ct_true,#TODO LUCAS
OPRLR_EQQ_REL = opr_atr opr_atr | oprlr_rel, The relational operator == (not detected directly from lexical.jl)
FN_H_BOOL = id FN_H_BOOL_V,#TODO LUCAS
FN_H_BOOL_V = vec_in EXPR_NUM | FN_CH | epsilon,#TODO LUCAS
ALL_ITER = ITER_IF ALL_ITER | VAR_DCLR ALL_ITER | ITER_WHILE ALL_ITER | ITER_FOR ALL_ITER | ITER_CTRL ALL_ITER | FCALL_OR_ATRIB ALL_ITER | epsilon,Union of all iterators
ITER_IF = if o_brckt EXPR_BOOL c_brckt o_c_brckt ALL_ITER c_c_brckt ITER_IF_R, If iterator
ITER_IF_R = else ITER_IF_RR | epsilon, Recursive fix for the If iterator
ITER_IF_RR = ITER_IF | o_c_brckt ALL_ITER c_c_brckt,Recursive fix for the If iterator (2)
ITER_WHILE = while o_brckt EXPR_BOOL o_brckt o_c_brckt ALL_ITER c_c_brckt, While Iterator
FOR_EXP_LIMITER = ID_OR_VEC oprlr_rel EXPR_NUM, The step limiter for the for block
ITER_FOR = for o_brckt VAR_DCLR comma FOR_EXP_LIMITER comma ID_OR_VEC opr_atr EXPR_NUM c_brckt o_c_brckt ALL_ITER c_c_brckt, For iterator
ITER_CTRL = continue | break | return DATA, Flux controllers
FN_CH = o_brckt FN_CHP,#TODO LUCAS
FN_CHP = FN_PR c_brckt | c_brckt,#TODO LUCAS
FN_PR = id FN_PRE | CT FN_PRE,#TODO LUCAS
FN_PRE = id comma FN_PR | epsilon, #TODO LUCAS
